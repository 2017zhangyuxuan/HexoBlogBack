---
title: C++简单线程池
date: 2023-11-17 16:40:58
hide: true
tags:
---



# 前言





# 互斥锁

- std::mutex
- std::lock_guard
- std::unique_lock
- std::scoped_lock

# 条件变量

condition_variable 条件变量是C++11中就有的class，通过使用 std::mutex 来实现同步原语，这里简单介绍下两个关键的成员函数[^1]。

## wait函数使用

正如 cppreference 里描述的那样，condition_variable 的 wait 函数提供了两种函数原型：

```C++
void wait (unique_lock<mutex>& lck);		（1）
template <class Predicate>
void wait (unique_lock<mutex>& lck, Predicate pred);		（2）
```

- 对于函数原型（1），执行 wait 函数，会直接解锁传入的互斥量并阻塞当前线程，直到其他的某个线程调用 notify_one 或者 notify_all 后，该线程被唤醒，**会重新尝试获取互斥量**，如果得不到线程就会阻塞在这里，直到获取到互斥量为止才会结束 wait，继续执行下面的代码。

- 对于函数原型（2），等同于如下的代码，该函数主要用于避免一些虚假唤醒（spurious awakenings）的情况，通过指定的判断条件决定是否继续等待。需要注意的事，**在进入该循环前，必须要获取到互斥量，而执行完 wait 后，也需要重新获取到互斥量**，即这里的互斥量会保护执行 stop_waiting() 。

- ```C++
  while (!stop_waiting())
  {
      wait(lock);
  }
  ```

---

wait 函数的具体使用方法可以参考下面代码[^2] 

```C++
#include <chrono>
#include <condition_variable>
#include <iostream>
#include <thread>

std::condition_variable cv;
std::mutex cv_m;    // This mutex is used for three purposes:
                    // 1) to synchronize accesses to i
                    // 2) to synchronize accesses to std::cerr
                    // 3) for the condition variable cv
int i = 0;

void waits(int num)
{
    std::unique_lock<std::mutex> lk(cv_m);
    std::cerr << "num:" << num << " Waiting...\n";
    cv.wait(lk, []{ return i == 1; });
    std::cerr << "num:" << num << " ...finished waiting. i == 1\n";
}

void signals()
{
    std::this_thread::sleep_for(std::chrono::seconds(1));
    {
        std::lock_guard<std::mutex> lk(cv_m);
        std::cerr << "Notifying...\n";
    }
    cv.notify_all();

    std::this_thread::sleep_for(std::chrono::seconds(1));

    {
        std::lock_guard<std::mutex> lk(cv_m);
        i = 1;
        std::cerr << "Notifying again...\n";
    }
    cv.notify_all();
}

int main()
{
    std::thread t1(waits, 1), t2(waits, 2), t3(waits, 3), t4(signals);
    t1.join();
    t2.join();
    t3.join();
    t4.join();
}
```

其中一组可能的输出为：

```bash
num:3 Waiting...
num:1 Waiting...
num:2 Waiting...
Notifying...
Notifying again...
num:3 ...finished waiting. i == 1
num:2 ...finished waiting. i == 1
num:1 ...finished waiting. i == 1
```

简单分析一下上面的代码和输出结果：在 main 函数中创建了三个 waits 线程和一个 signals 线程，然后主线程等待所有线程执行完毕。由于 signals 线程会先 sleep 1 秒，所以先执行三个 waits 线程，而这三个线程执行的顺序是随机的，当其中一个线程先执行拿到锁后，执行输出 Waiting（输出结果里第一个执行的就是线程3），然后执行 wait ，由于不满足条件所以会释放锁并阻塞当前线程。紧接着，其他两个由于没有拿到互斥锁而被阻塞的线程，其中一个拿到了锁，也继续往下执行，重复类似的操作。最后三个线程都在等待被唤醒。

signals 线程睡眠完之后，继续往下执行，第一次执行 notify_all，唤醒了等待的三个线程，而每个线程唤醒也都会去尝试获取互斥锁，因此此时三个线程还是相当于以随机顺序串行执行，但是因为没有满足退出等待的条件（i == 1），所以又会释放锁并进入等待。signals 线程将 i 赋值为1后，第二次执行 notify_all，此时waits 三个线程依次拿到锁，并判断结束条件成立后，继续往下执行输出，最终输出的顺序也是随机的。



## notify_one & notify_all

```C++
void notify_one() noexcept;
void notify_all() noexcept;
```

两个 notify 的函数原型也都比较简单，其中 notify_one 是去唤醒当前条件变量等待队列里的一个线程，如果没有线程在等待，则函数不执行任何操作，如果等待的线程多于一个，则唤醒的线程是随机的。notify_all 则是去唤醒所有正在等待的线程。

 在 cppreference 指出，通知线程不需要持有与等待线程线程相同的互斥锁，如果持有的话，反而可能是一种性能劣化，因为被通知的线程因为无法获取到锁而再次阻塞，直到通知线程释放锁。因此，一些实现（特别是许多pthread实现）为识别这种情况，在 notify 调用中，会直接将等待线程从条件变量的等待队列中转移到互斥锁的等待队列里，从而避免了这种 “hurry up and wait” 情况。




# 线程池实现









[^1]: [C++11条件变量condition_variable详解](https://zhuanlan.zhihu.com/p/599172163)
[^2]: [condition_variable wait 示例代码](https://en.cppreference.com/w/cpp/thread/condition_variable/wait)
